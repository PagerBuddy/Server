<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>messaging.mjs - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Config_Config.html">Config</a></li><li><a href="database_database.html">database</a></li><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3>Modules</h3><ul><li><a href="module-backup.html">backup</a><ul class='methods'><li data-type='method'><a href="module-backup.html#~copy_db">copy_db</a></li><li data-type='method'><a href="module-backup.html#~get_current_timestamp">get_current_timestamp</a></li></ul></li><li><a href="module-health.html">health</a><ul class='methods'><li data-type='method'><a href="module-health.html#.get_health_report">get_health_report</a></li><li data-type='method'><a href="module-health.html#.get_time_offset">get_time_offset</a></li><li data-type='method'><a href="module-health.html#.init">init</a></li><li data-type='method'><a href="module-health.html#.radio_activity">radio_activity</a></li><li data-type='method'><a href="module-health.html#.report_health">report_health</a></li><li data-type='method'><a href="module-health.html#.telegram_status">telegram_status</a></li></ul></li><li><a href="module-logging.html">logging</a><ul class='methods'><li data-type='method'><a href="module-logging.html#.connect_telegram_transport">connect_telegram_transport</a></li><li data-type='method'><a href="module-logging.html#.set_logging_level">set_logging_level</a></li></ul></li><li><a href="module-messaging.html">messaging</a><ul class='methods'><li data-type='method'><a href="module-messaging.html#.heartbeatProbe">heartbeatProbe</a></li><li data-type='method'><a href="module-messaging.html#.init">init</a></li><li data-type='method'><a href="module-messaging.html#.sendAlert">sendAlert</a></li><li data-type='method'><a href="module-messaging.html#.sendTest">sendTest</a></li><li data-type='method'><a href="module-messaging.html#~getAccessToken">getAccessToken</a></li><li data-type='method'><a href="module-messaging.html#~getFCMJSON">getFCMJSON</a></li><li data-type='method'><a href="module-messaging.html#~sendFcmMessages">sendFcmMessages</a></li></ul></li><li><a href="module-server.html">server</a><ul class='methods'><li data-type='method'><a href="module-server.html#.queue_alarm">queue_alarm</a></li><li data-type='method'><a href="module-server.html#.start">start</a></li><li data-type='method'><a href="module-server.html#.stop">stop</a></li><li data-type='method'><a href="module-server.html#~alarm">alarm</a></li><li data-type='method'><a href="module-server.html#~queue_katsys">queue_katsys</a></li><li data-type='method'><a href="module-server.html#~run_queue">run_queue</a></li><li data-type='method'><a href="module-server.html#~setup_cleaner">setup_cleaner</a></li><li data-type='method'><a href="module-server.html#~step_alarms">step_alarms</a></li></ul></li><li><a href="module-websocket.html">websocket</a><ul class='methods'><li data-type='method'><a href="module-websocket.html#.init">init</a></li><li data-type='method'><a href="module-websocket.html#.start_listening">start_listening</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#create_database">create_database</a></li><li><a href="global.html#levelToZVEI">levelToZVEI</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">messaging.mjs</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**@module messaging */

import { google } from 'googleapis';
import * as  https from 'https';
import loggers from './logging.mjs'
import winston from 'winston';
import * as DB from './db.mjs';
import ZVEI from './model/zvei.mjs'
import { User } from './model/user.mjs';

/**@type {boolean} */
let ENABLED = false;

/**@type {DB.database} */
let db;

/**@type {winston.Logger} */
let log;

/**@type {Object.&lt;string,string>} */
let FCM_CREDENTIALS;

/** @type {string} */
let ALERT_TIME_ZONE = "";

/**
 * 
 * @param {DB.database} database 
 * @param {string} timezone 
 * @param {{enabled: boolean, fcm_credentials: Object.&lt;string, string>}} config 
 */
export function init(database, timezone, config) {
  log = loggers("Messaging");
  ENABLED = config.enabled;
  db = database;
  ALERT_TIME_ZONE = timezone;
  FCM_CREDENTIALS = config.fcm_credentials;
}

/**
 * Send an FCM/APNS package containing the alert to the list of devices.
 * @param {Array&lt;{token: string, chat_id: string, user_id: number}>} token_chat_array: The FCM tokens (and the causing chatIDs) to send the package to.
 * @param {number} alert_timestamp: The timestamp (in system time zone) when the alert was received.
 * @param {string} alert_time_zone The alert ID. Use this to obtain an alert description from DB.
 * @param {ZVEI} zvei The ZVEI that is to be alerted
 * @returns {Promise&lt;boolean>} True if all alerts were sent successfully, false otherwise.
 */
export async function sendAlert(token_chat_array, alert_timestamp, alert_time_zone, zvei) {
  if (!ENABLED) {
    return false;
  }


  const date = new Date();
  const offset = date.getTimezoneOffset(); //TZ offset to UTC in min

  let messages = [];
  /**@type {number[]} */
  let user_ids = [];
  for (let item in token_chat_array) {
    messages.push(
      getFCMJSON(token_chat_array[item].token,
        parseInt(token_chat_array[item].chat_id),
        zvei.id, zvei.description,
        zvei.is_test_time(alert_timestamp, alert_time_zone),
        alert_timestamp + offset,
        false)
    );
    user_ids.push(token_chat_array[item].user_id);
  }

  return await sendFcmMessages(messages, user_ids);
}

/**
  * Construct and send an FCM test message to supplied token.
  * @param {string} token: FCM device token.
  * @param {number} chat_id: ID that requested alert.
  * @param {number} user_id: User that requested alert.
  * @returns {Promise&lt;boolean>} True if message was sent successfully.
  */
export async function sendTest(token, chat_id, user_id) {
  if (!ENABLED) {
    return false;
  }

  const date = new Date();
  const alert_timestamp = Date.now() + date.getTimezoneOffset();

  let alert_zvei_id = 99999;
  let alert_zvei_description = "PagerBuddy alert test.";

  let messages = [];
  let user_ids = [];
  messages.push(getFCMJSON(token, chat_id, alert_zvei_id, alert_zvei_description, false, alert_timestamp, true));
  user_ids.push(user_id);
  return await sendFcmMessages(messages, user_ids);
}

/**
 * Send a list of FCM JSON messages to the FCM server.
 * @param {string[]} fcmMessage The list of well-formatted JSON payloads.
 * @param {number[]} user_ids List of user ids linked to the FCM messages.
 * @returns {Promise&lt;boolean>} True if all messages were sent successfully, false otherwise.
 */

async function sendFcmMessages(fcmMessage, user_ids) {

  const accessToken = await getAccessToken();

  const key = FCM_CREDENTIALS;

  const options = {
    hostname: 'fcm.googleapis.com',
    path: '/v1/projects/' + key.project_id + '/messages:send',
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + accessToken
    }
  };

  let promises = [];
  for (var msg in fcmMessage) {
    let promise_res = new Promise((resolve, reject) => {
      const request = https.request(options, function (resp) {
        resp.setEncoding('utf8');
        resp.on('data', function (data) {
          let jsonResponse;
          try {
            jsonResponse = JSON.parse(data);
          } catch (error) {
            log.error("Error sending FCM message. Response too large to parse: " + data);
            reject(data);
            return;
          }
          if (jsonResponse.error != null) {
            if (jsonResponse.error.code == 404 &amp;&amp; jsonResponse.error.status == "NOT_FOUND") {
              //Device ID does not exist (any more) - delete it.
              const user_id = user_ids[msg];
              log.debug("FCM responded entity not found. Removing user.");
              
              let user = new User(user_id, "", "");
              db.remove_user(user);
            } else {
              log.error("Error sending FCM message: " + data);
            }
            reject(jsonResponse.error);
          } else {
            log.silly('Message sent to Firebase for delivery, response:');
            log.silly(data);
            resolve(data);
          }

        });
      });

      request.on('error', function (err) {
        log.warn('Unable to send message to Firebase');
        log.warn(err);
        reject(err);
      });

      request.write(fcmMessage[msg]);
      request.end();
    });

    promises.push(promise_res);
  }

  const values = await Promise.allSettled(promises);
  for (let element in values) {
    if (values[element].status == "rejected") {
      return false;
    }
  }
  return true;
}

/**
 * Get a short-lived access token from FCM server.
 * @returns {Promise&lt;string|null|undefined|Error>} A promise that will resolve an access token on success.
 */
function getAccessToken() {

  return new Promise(function (resolve, reject) {
    const MESSAGING_SCOPE = 'https://www.googleapis.com/auth/firebase.messaging';
    const SCOPES = [MESSAGING_SCOPE];

    const key = FCM_CREDENTIALS;
    const jwtClient = new google.auth.JWT(
      key.client_email,
      "",
      key.private_key,
      SCOPES,
      ""
    );
    jwtClient.authorize(function (err, tokens) {
      if (err) {
        reject(err);
        return;
      }
      resolve(tokens?.access_token);
    });
  });
}
/**
 * Constructs the FCM message to be sent.
 * @param {string} device_token The FCM token to send to.
 * @param {number} chat_id The linked chat ID causing the FCM alert.
 * @param {number} zvei_id The ZVEI (typically 5 digits) of the alerted unit.
 * @param {string} zvei_description A text description of the unit
 * @param {boolean} is_test_time Whether the test time filter is active.
 * @param {number} alert_timestamp The UNIX-timestamp of the alert.
 * @param {boolean} manual_test If this alert was requested by the user.
 * @returns {string} A ready to send JSON payload.
 */
function getFCMJSON(device_token, chat_id, zvei_id, zvei_description, is_test_time, alert_timestamp, manual_test) {

  const fcm_ttl = 15 * 60; //Remove alert after 15min, if not delivered

  //FCM only knows strings!
  let fcm = {
    message: {
      token: device_token,
      data: {
        zvei: zvei_id.toString(),
        zvei_description: zvei_description,
        is_test_alert: is_test_time.toString(),
        alert_timestamp: alert_timestamp.toString(),
        chat_id: chat_id.toString(),
        is_manual_test_alert: manual_test.toString()
      },
      android: {
        priority: "high",
        ttl: fcm_ttl.toString() + "s"
      },
      apns: {
        headers: {
          "apns-priority": "10",
          "apns-expiration": (Math.round(alert_timestamp / 1000) + fcm_ttl).toString()
        },
        payload: {
          aps: {}
        }
      }
    }
  }

  const timestamp_obj = new Date(alert_timestamp);
  const timestamp_string = timestamp_obj.toLocaleTimeString("de-DE", { hour: "2-digit", minute: "2-digit", second: "2-digit", timeZone: ALERT_TIME_ZONE });

  const msg_body = zvei_description;

  if (is_test_time) {
    let aps = {
      alert: {
        "title-loc-key": "TEST_ALERT_TITLE",
        "loc-key": "TEST_ALERT_MESSAGE",
        "loc-args": [msg_body, timestamp_string]
      },
      sound: {
        critical: 1,
        name: "pagerbuddy_sound_long.wav",
        volume: 0.5
      },
      "interruption-level": "critical"
    }
    fcm.message.apns.payload.aps = aps;
  } else {
    let aps = {
      alert: {
        "title-loc-key": "ALERT_TITLE",
        "loc-key": "ALERT_MESSAGE",
        "loc-args": [msg_body, timestamp_string]
      },
      sound: {
        critical: 1,
        name: "pagerbuddy_sound_long.wav",
        volume: 1.0
      },
      "interruption-level": "critical"
    }
    fcm.message.apns.payload.aps = aps;
  }

  const json = JSON.stringify(fcm);
  return json;

}

/**
 * Sends a non-user-facing notification to the specified tokens to check if the tokens are (still) valid. Possibly necessary cleanup is handled in the send function.
 * @param {Array&lt;{user_id: number, token: string}>} check_list List of users to check.
 */
export async function heartbeatProbe(check_list) {

  /**@type {string[]} */
  let message_list = [];
  /**@type {number[]} */
  let user_list = [];

  check_list.forEach(item => {
    const fcm = {
      message: {
        token: item.token,
        apns: {
          headers: {
            "apns-priority": "5"
          }
        }
      }
    }
    const json = JSON.stringify(fcm);

    message_list.push(json);
    user_list.push(item.user_id);

  });

  await sendFcmMessages(message_list, user_list);
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Oct 03 2022 07:13:38 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
